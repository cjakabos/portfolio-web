/* eslint-disable */
// Generated by scripts/contracts/openapi_contracts.py from contracts/openapi/vehicles.json
// Source API: Vehicle REST API v1.0

export const VEHICLES_OPERATIONS = [
  {
    id: "list",
    method: "GET",
    path: "/cars",
    summary: "",
    tags: ["car-controller"] as const,
    pathParams: [] as const,
    queryParams: [] as const,
    hasRequestBody: false,
    responseStatuses: ["200"] as const,
  },
  {
    id: "post",
    method: "POST",
    path: "/cars",
    summary: "",
    tags: ["car-controller"] as const,
    pathParams: [] as const,
    queryParams: [] as const,
    hasRequestBody: true,
    responseStatuses: ["200"] as const,
  },
  {
    id: "delete",
    method: "DELETE",
    path: "/cars/{id}",
    summary: "",
    tags: ["car-controller"] as const,
    pathParams: ["id"] as const,
    queryParams: [] as const,
    hasRequestBody: false,
    responseStatuses: ["200"] as const,
  },
  {
    id: "get",
    method: "GET",
    path: "/cars/{id}",
    summary: "",
    tags: ["car-controller"] as const,
    pathParams: ["id"] as const,
    queryParams: [] as const,
    hasRequestBody: false,
    responseStatuses: ["200"] as const,
  },
  {
    id: "put",
    method: "PUT",
    path: "/cars/{id}",
    summary: "",
    tags: ["car-controller"] as const,
    pathParams: ["id"] as const,
    queryParams: [] as const,
    hasRequestBody: true,
    responseStatuses: ["200"] as const,
  },
] as const;

export type VehiclesOperation = typeof VEHICLES_OPERATIONS[number];
export type VehiclesOperationId = VehiclesOperation["id"];
export type VehiclesOperationMethod = VehiclesOperation["method"];
export type VehiclesOperationPath = VehiclesOperation["path"];

export const vehiclesOperationById: Record<VehiclesOperationId, VehiclesOperation> =
  Object.fromEntries(VEHICLES_OPERATIONS.map((op) => [op.id, op])) as Record<VehiclesOperationId, VehiclesOperation>;

export type RequestQueryValue = string | number | boolean | null | undefined;
export type RequestQuery = Record<string, RequestQueryValue | RequestQueryValue[]>;

export interface OperationRequestOptions {
  pathParams?: Record<string, string | number>;
  query?: RequestQuery;
  body?: unknown;
  headers?: HeadersInit;
  credentials?: RequestCredentials;
  signal?: AbortSignal;
}

export interface VehiclesClientConfig {
  baseUrl: string;
  defaultHeaders?: HeadersInit;
  defaultCredentials?: RequestCredentials;
  fetchImpl?: typeof fetch;
}

function buildUrl(pathTemplate: string, baseUrl: string, pathParams: Record<string, string | number> = {}, query?: RequestQuery) {
  const substituted = pathTemplate.replace(/{([^}/]+)}/g, (_, key: string) => {
    const value = pathParams[key];
    if (value === undefined || value === null) {
      throw new Error(`Missing path param: ${key}`);
    }
    return encodeURIComponent(String(value));
  });

  const url = new URL(substituted, baseUrl.endsWith("/") ? baseUrl : `${baseUrl}/`);
  if (query) {
    for (const [key, raw] of Object.entries(query)) {
      if (raw === undefined || raw === null) continue;
      if (Array.isArray(raw)) {
        for (const value of raw) {
          if (value === undefined || value === null) continue;
          url.searchParams.append(key, String(value));
        }
      } else {
        url.searchParams.set(key, String(raw));
      }
    }
  }
  return url.toString();
}

export class VehiclesApiClient {
  private readonly baseUrl: string;
  private readonly defaultHeaders?: HeadersInit;
  private readonly defaultCredentials?: RequestCredentials;
  private readonly fetchImpl: typeof fetch;

  constructor(config: VehiclesClientConfig) {
    this.baseUrl = config.baseUrl;
    this.defaultHeaders = config.defaultHeaders;
    this.defaultCredentials = config.defaultCredentials;
    this.fetchImpl = config.fetchImpl ?? fetch;
  }

  async request<T = unknown>(operationId: VehiclesOperationId, options: OperationRequestOptions = {}): Promise<T> {
    const op = vehiclesOperationById[operationId];
    const url = buildUrl(op.path, this.baseUrl, options.pathParams, options.query);
    const headers = new Headers(this.defaultHeaders);
    if (options.headers) {
      new Headers(options.headers).forEach((value, key) => headers.set(key, value));
    }
    let body: BodyInit | undefined;
    if (options.body !== undefined) {
      if (!headers.has("Content-Type")) {
        headers.set("Content-Type", "application/json");
      }
      body = headers.get("Content-Type")?.includes("application/json")
        ? JSON.stringify(options.body)
        : (options.body as BodyInit);
    }

    const response = await this.fetchImpl(url, {
      method: op.method,
      headers,
      body,
      credentials: options.credentials ?? this.defaultCredentials,
      signal: options.signal,
    });

    if (!response.ok) {
      const text = await response.text().catch(() => "");
      throw new Error(`API request failed (${op.method} ${op.path}): ${response.status} ${text}`);
    }

    if (response.status === 204) {
      return undefined as T;
    }
    return (await response.json()) as T;
  }
}
