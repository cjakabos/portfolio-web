name: Nightly - AI Integrations

on:
  schedule:
    - cron: "0 2 * * *"
  workflow_dispatch:

concurrency:
  group: nightly-ai-integrations-${{ github.ref }}
  cancel-in-progress: true

jobs:
  nightly-ai-e2e:
    name: Nightly AI E2E (ChatLLM + Monitor + Jira)
    runs-on: ubuntu-latest
    timeout-minutes: 180

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Prepare CI bind mounts
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p logs
          chmod 0777 logs
          ls -ld logs

      - name: Create .env for nightly stack
        shell: bash
        env:
          JIRA_DOMAIN: ${{ secrets.JIRA_DOMAIN }}
          JIRA_EMAIL: ${{ secrets.JIRA_EMAIL }}
          JIRA_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}
          JIRA_PROJECT_KEY: ${{ secrets.JIRA_PROJECT_KEY }}
        run: |
          cat > .env <<EOF
          JWT_SECRET=nightly-ci-jwt-secret-change-me
          JWT_EXPIRATION_MS=3600000
          JWT_PRIVATE_KEY_FILE=${GITHUB_WORKSPACE}/localhost+3-key.pem
          JWT_PUBLIC_KEY_FILE=${GITHUB_WORKSPACE}/localhost+3-key.pub

          INTERNAL_SERVICE_TOKEN=nightly-internal-token

          POSTGRES_USER=nightly_user
          POSTGRES_PASSWORD=nightly_pass
          POSTGRES_DB=cloudappdb

          POSTGRES_ML_USER=nightly_ml_user
          POSTGRES_ML_PASSWORD=nightly_ml_pass
          POSTGRES_ML_DB=segmentationdb

          MYSQL_ROOT_USERNAME=root
          MYSQL_ROOT_PASSWORD=nightly_mysql_pass
          MYSQL_DATABASE=petstore

          MONGO_USER=nightly_mongo_user
          MONGO_PASSWORD=nightly_mongo_pass
          MONGO_DB=cloudappdb

          MONGO_ABTEST_USER=admin
          MONGO_ABTEST_PASSWORD=nightly_abtest_admin_pass
          MONGO_ABTEST_ORCH_USER=orchestration_user
          MONGO_ABTEST_ORCH_PASSWORD=nightly_abtest_orch_pass

          JIRA_DOMAIN=${JIRA_DOMAIN:-https://example.atlassian.net}
          JIRA_API_TOKEN=${JIRA_API_TOKEN:-missing-token}
          JIRA_PROJECT_KEY=${JIRA_PROJECT_KEY:-PROJ}
          JIRA_EMAIL=${JIRA_EMAIL:-missing@example.com}

          LLM_MODEL=qwen3:1.7b
          LLM_MODEL_EMBEDDING=qwen3-embedding:4b
          OLLAMA_URL=http://ollama:11434

          OTEL_ENABLED=false
          GRAFANA_PASSWORD=nightly-grafana-pass

          CLOUDAPP_URL=http://next-nginx-jwt:80/cloudapp
          PETSTORE_URL=http://next-nginx-jwt:80/petstore
          VEHICLES_URL=http://next-nginx-jwt:80/vehicles
          ML_URL=http://next-nginx-jwt:80/mlops-segmentation

          CHROMA_HOST=chromadb
          CHROMA_PORT=8000
          CHROMA_COLLECTION=user_documents
          CHROMA_PERSIST_DIR=/data/chroma

          ENABLE_CHECKPOINTING=true
          ENABLE_HITL=true
          ENABLE_PARALLEL=true
          ENABLE_ERROR_HANDLING=true
          ENABLE_AB_TESTING=true

          REDIS_MAX_CONNECTIONS=50
          ENVIRONMENT=development

          LLM_TEMPERATURE=0.7
          LLM_MAX_TOKENS=2000
          RAG_SEARCH_K=3

          HTTP_TIMEOUT=10
          HTTP_MAX_CONNECTIONS=100
          HTTP_MAX_KEEPALIVE=20

          LOG_LEVEL=INFO
          LOG_FORMAT=json
          ENABLE_FILE_LOGGING=false
          EOF

      - name: Start infrastructure stack (with Ollama profile)
        run: |
          docker compose -f docker-compose-infrastructure.yml --profile ollama up -d --build

      - name: Wait for infrastructure readiness
        shell: bash
        run: |
          set -euo pipefail

          wait_for_http() {
            local url="$1"
            local name="$2"
            local attempts="${3:-60}"

            for i in $(seq 1 "$attempts"); do
              if curl -sf "$url" >/dev/null; then
                echo "$name is ready"
                return 0
              fi
              sleep 5
            done

            echo "$name did not become ready in time: $url"
            docker compose -f docker-compose-infrastructure.yml --profile ollama ps || true
            docker compose -f docker-compose-infrastructure.yml --profile ollama logs --tail=200 || true
            return 1
          }

          wait_for_container_health() {
            local container="$1"
            local name="$2"
            local attempts="${3:-60}"

            for i in $(seq 1 "$attempts"); do
              local state
              local health
              state="$(docker inspect --format '{{.State.Status}}' "$container" 2>/dev/null || true)"
              health="$(docker inspect --format '{{if .State.Health}}{{.State.Health.Status}}{{else}}none{{end}}' "$container" 2>/dev/null || true)"

              if [[ "$state" == "running" && "$health" == "healthy" ]]; then
                echo "$name is healthy"
                return 0
              fi

              if (( i % 12 == 0 )); then
                echo "$name health attempt $i/$attempts: state=${state:-missing} health=${health:-missing}"
              fi
              sleep 5
            done

            echo "$name failed health check (container=$container)"
            docker compose -f docker-compose-infrastructure.yml --profile ollama ps || true
            docker logs --tail=200 "$container" || true
            return 1
          }

          wait_for_http "http://localhost:11434/api/tags" "Ollama"
          wait_for_container_health "redis-cache" "Redis"
          wait_for_container_health "mongodb-abtest" "MongoDB AB Test"
          wait_for_container_health "chromadb" "ChromaDB"

      - name: Pull nightly AI models in Ollama
        run: |
          set -euo pipefail

          pull_model() {
            local model="$1"
            local attempts="${2:-3}"

            for i in $(seq 1 "$attempts"); do
              if docker exec ollama ollama pull "$model"; then
                echo "Pulled model: $model"
                return 0
              fi
              echo "Failed to pull $model (attempt $i/$attempts)"
              sleep 15
            done

            echo "Giving up on model pull: $model"
            docker logs --tail=200 ollama || true
            return 1
          }

          pull_model qwen3:1.7b
          pull_model qwen3-embedding:4b
          docker exec ollama ollama list

      - name: Start application stack
        run: |
          docker compose -f docker-compose-app.yml up -d --build

      - name: Wait for app endpoints
        shell: bash
        run: |
          set -euo pipefail

          wait_for() {
            local url="$1"
            local name="$2"
            local container="${3:-}"
            for i in {1..90}; do
              if curl -sf "$url" >/dev/null; then
                echo "$name is ready"
                return 0
              fi
              sleep 5
            done
            echo "$name failed readiness: $url"
            docker compose -f docker-compose-app.yml ps || true
            docker compose -f docker-compose-infrastructure.yml --profile ollama ps || true
            if [[ -n "$container" ]]; then
              docker logs --tail=200 "$container" || true
            fi
            return 1
          }

          wait_for_ai_health() {
            local url="http://localhost:80/ai/health"
            local attempts=180
            local body_file="/tmp/nightly-ai-health.json"

            for i in $(seq 1 "$attempts"); do
              local code
              code="$(curl -sS -o "$body_file" -w '%{http_code}' "$url" || true)"

              if [[ "$code" == "200" ]]; then
                echo "AI orchestration layer is ready"
                return 0
              fi

              if (( i % 12 == 0 )); then
                echo "AI orchestration health attempt $i/$attempts failed (HTTP $code)"
                docker inspect --format 'status={{.State.Status}} health={{if .State.Health}}{{.State.Health.Status}}{{else}}none{{end}}' ai-orchestration-layer || true
              fi
              sleep 5
            done

            echo "AI orchestration layer failed readiness: $url"
            echo "Last /ai/health response:"
            cat "$body_file" || true
            docker compose -f docker-compose-app.yml ps || true
            docker compose -f docker-compose-infrastructure.yml --profile ollama ps || true
            docker inspect --format 'status={{.State.Status}} health={{if .State.Health}}{{.State.Health.Status}}{{else}}none{{end}}' ai-orchestration-layer || true
            docker logs --tail=200 ai-orchestration-layer || true
            return 1
          }

          wait_for_cloudapp_login() {
            local url="http://localhost/cloudapp/user/user-login"
            local attempts=90
            local body_file="/tmp/nightly-cloudapp-login-probe.json"
            local payload='{"username":"ci_probe","password":"ci_probe"}'

            for i in $(seq 1 "$attempts"); do
              local code
              code="$(curl -sS -o "$body_file" -w '%{http_code}' \
                -H 'Content-Type: application/json' \
                -X POST "$url" \
                --data "$payload" || true)"

              if [[ "$code" == "200" || "$code" == "401" ]]; then
                echo "CloudApp auth endpoint is ready (HTTP $code)"
                return 0
              fi

              if (( i % 12 == 0 )); then
                echo "CloudApp auth probe attempt $i/$attempts failed (HTTP $code)"
                docker logs --tail=100 cloudapp || true
                docker logs --tail=100 next-nginx-jwt || true
              fi
              sleep 5
            done

            echo "CloudApp auth endpoint failed readiness: $url"
            cat "$body_file" || true
            docker compose -f docker-compose-app.yml ps || true
            docker logs --tail=200 cloudapp || true
            docker logs --tail=200 next-nginx-jwt || true
            return 1
          }

          wait_for "http://localhost/nginx_health" "Nginx gateway" "next-nginx-jwt"
          wait_for_cloudapp_login
          wait_for "http://localhost:5001" "CloudApp shell" "next-cloudapp-shell"
          wait_for "http://localhost:5003" "Jira remote" "next-jira"
          wait_for "http://localhost:5333" "ChatLLM remote" "next-chatllm"
          wait_for "http://localhost:5010" "AI monitor" "ai-orchestration-monitor"
          wait_for_ai_health

      - name: Resolve Jira nightly flag
        id: jira
        shell: bash
        env:
          JIRA_DOMAIN: ${{ secrets.JIRA_DOMAIN }}
          JIRA_EMAIL: ${{ secrets.JIRA_EMAIL }}
          JIRA_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}
          JIRA_PROJECT_KEY: ${{ secrets.JIRA_PROJECT_KEY }}
        run: |
          if [[ -n "${JIRA_DOMAIN}" && -n "${JIRA_EMAIL}" && -n "${JIRA_API_TOKEN}" && -n "${JIRA_PROJECT_KEY}" ]]; then
            echo "enabled=1" >> "$GITHUB_OUTPUT"
            echo "project_key=${JIRA_PROJECT_KEY}" >> "$GITHUB_OUTPUT"
          else
            echo "enabled=0" >> "$GITHUB_OUTPUT"
            echo "project_key=" >> "$GITHUB_OUTPUT"
            echo "Jira secrets are missing; Jira nightly spec will be skipped."
          fi

      - name: Install Playwright dependencies
        working-directory: frontend/cloudapp-shell
        run: npm ci

      - name: Install Chromium for Playwright
        working-directory: frontend/cloudapp-shell
        run: npx playwright install --with-deps chromium

      - name: Run nightly AI integration specs
        working-directory: frontend/cloudapp-shell
        env:
          BASE_URL: http://localhost:5001
          BACKEND_URL: http://localhost:80
          MONITOR_URL: http://localhost:5010
          NIGHTLY_AI_E2E: "1"
          NIGHTLY_CHAT_MODEL: qwen3:1.7b
          NIGHTLY_RAG_MODEL: qwen3:1.7b
          NIGHTLY_EMBEDDING_MODEL: qwen3-embedding:4b
          NIGHTLY_ENABLE_JIRA_E2E: ${{ steps.jira.outputs.enabled }}
          NIGHTLY_JIRA_PROJECT_KEY: ${{ steps.jira.outputs.project_key }}
        run: |
          NODE_PATH=./node_modules npx playwright test \
            nightly-chatllm-ollama.spec.ts \
            nightly-monitor-models.spec.ts \
            nightly-jira-ai.spec.ts \
            --project=chromium \
            -c ../../playwright.config.ts

      - name: Collect Playwright artifacts
        if: always()
        shell: bash
        run: |
          mkdir -p playwright-artifacts
          cp -R playwright-report playwright-artifacts/playwright-report-root 2>/dev/null || true
          cp -R test-results playwright-artifacts/test-results-root 2>/dev/null || true
          cp -R frontend/cloudapp-shell/playwright-report playwright-artifacts/playwright-report-shell 2>/dev/null || true
          cp -R frontend/cloudapp-shell/test-results playwright-artifacts/test-results-shell 2>/dev/null || true

      - name: Upload Playwright artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: nightly-ai-playwright-artifacts
          path: playwright-artifacts/
          retention-days: 14

      - name: Dump Docker logs on failure
        if: failure()
        run: |
          docker compose -f docker-compose-app.yml ps || true
          docker compose -f docker-compose-infrastructure.yml ps || true
          docker compose -f docker-compose-app.yml logs --tail=300 || true
          docker compose -f docker-compose-infrastructure.yml logs --tail=300 || true

      - name: Teardown stacks
        if: always()
        run: |
          docker compose -f docker-compose-app.yml down -v --remove-orphans || true
          docker compose -f docker-compose-infrastructure.yml --profile ollama down -v --remove-orphans || true
